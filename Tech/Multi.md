## Python多任务处理
### 多线程
* 多线程是指电脑通过不断切换任务来实现多任务的并行处理，但在Python中因为有GIL的出现，导致每个时候每个进程(独立的GIL)只有一个线程在运行，因此在Python中单核多线程意义不大(可以应对IO密集型的，CPU资源占用不多，主要时间等待的任务)。
* 线程的操作：
    * Thread(target = fun, args) 由该类实例化的对象表示一个线程，但是还未启动
    * t.start() 启动线程
    * t.join() 主线程等待t线程终止，而不会影响其他的线程
    * 多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，为了限制这种情况，对于全局变量的修改需要锁内存
    * Lock() 由该类实例化的对象表示线程锁，使用l.lock()表示对变量的独占，release()表示释放对变量的独占
    * 多线程池 ：表示将所有的任务丢进进程池里面，python会自动解决分配问题
        * from multiprocessing.pool import ThreadPool：定义一个线程池
        * p.map(target,iter_args) 输入要完成的任务和可迭代的参数，可以返回多个结果的列表，不需要queue
* 由于Python多线程无法利用多核优势，就必须使用多进程来进行多任务的处理。
### 多进程
* 多进程是指利用多核CPU，每个CPU开启一个线程，分别执行不会互相影响，但是同一个变量，每个进程中都有各自的拷贝，内存空间是隔离的，因此互相通信就成了难点。(CPU密集型的，主要是CPU进行计算)
* 进程的操作与线程很像：
    * Process(target = fun,args = (a,)) 由该类实例化的对象表示一个进程，但是还未启动
    * p.start() 启动进程
    * p.join() 主线程等待p进程终止，而不会影响其他的进程
    * 保存进程输出，可以利用queue来实现，同时也可用于线程保存输出
        * multiprocess.Queue() 实例化的对象表示产生一个队列，并且是锁安全的，先进先出
        * q.put() 插入队列，如果队列已满，这句话将会堵塞
        * q.get() 从队列中读取，如果队列已空，将会堵塞
    * 进程池：表示将所有的任务丢进进程池里面，python会自动解决分配问题
        * multiprocess.Pool(n) 实例化的对象有n个进程可供利用
        * p.map(job,iter_args) 输入要完成的任务和可迭代的参数，可以返回多个结果的列表，不需要queue
        * (与上面的map功能类似)p.apply_async()只能放入一组参数，返回一个结果，如果需要多个结果的话可以进行迭代
    * 多进程中，所有变量都是原始变量的一份拷贝，因此就需要互相之间进行通信。
* 多进程需要通信
    * Queue是锁安全的
        * q.put() 插入队列，如果队列已满，这句话将会堵塞
        * q.get() 从队列中读取，如果队列已空，将会堵塞
        * q.empty() 返回是否队列为空，结果不可靠
        * q.full() 返回队列是否满， 结果不可靠
        * q.qsize() 返回队列的数量，结果不可靠
    * 共享内存
        * multiprocess.Value(type,init) 传入数据类型和初始值
        * 需要更改的时候直接修改即可
        * 需要加锁
            * multiprocess.Lock()
            * l.lock()表示对变量的独占
            * l.release()表示释放对变量的独占
### 注意事项
* 多线程是共享变量的，因此对某一个变量进行操作的时候需要加锁
* 多进程是变量互相独立的，当需要通讯的时候有两种方式：
    * 共享内存：读取效率高，修改方便，但是要确保互相之间不会干扰，必要时候也需要加锁
    * Queue进行保存：是锁安全的，但是互相之间通信次数比较多的话，速度会非常慢，因此适用于仅仅交换几次的状态
* 返回变量：
    * 写到文件中，但是这种情况下，读写速度比较慢
    * 写到queue里面但是如果多个进程同时写的话也会比较慢
    * 直接函数返回，需要用到Pool来进行返回，但是这个似乎跟共享内存有冲突